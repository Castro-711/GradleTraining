/*
    1. Make the `date` task depend on the `hello` task.
    2. Execute the `date` task.
    3. Execute `gradle tasks --all`.
    4. The `--dry-run` (or `-m`) command line option executes the build but disables all actions. Execute `date` with the `--dry-run` option.
    5. Add some top level `println` statements to the script.
    6. Add a `println` statement to the configuration block of the `date` task.
    7. Execute the `hello` task and analyze the output.
*/

println 'This is the 4th lab and covers the build lifecycle'

task hello {
    // dependsOn 'date' // - gradle very good at detecting circular dependencies
    println 'Config block of hello'
    doLast {
        println "Hello World"
    }
}

println 'Top-level, between hell & date'
task date {
    dependsOn hello // makes date depend on hello
    // this is one of multiple ways to do it
    // instructor uses quotes - reason why? pending...
    // if the dependent task is declared before its dependee
    // it will think its a variable and cause an error
    // watch out for this.. 
    // by including '' you will avoid this issue !!!
    println 'Config block of date'
    doLast {
        println new Date()
    }
}

task hi(type: Greeting) {
    user = 'Jurgen'
    doLast {
        println 'Just greeted the best manager in the World'
    }
    doFirst {
        println 'About to greet Jurgen'
    }
}

// Default tasks don't have a task action
// hence why we need doFirst / doLast 
// doFirst -> preprocessing before action
// doLast  -> postprocessing after action

// custom task
class Greeting extends DefaultTask {
    // normally don't leave classes here. 
    String user = 'World'

    @TaskAction
    void sayHello() {
        println("Hello, ${user}!")
    }
}


/*
BUILD LIFECYCLE:
* Init Phase
    * Configure environment (init.gradle, gradle.properties)
    * Find projects and build scripts (settings.gradle)
    ** Figure out which build file to execute ** 

* Configuraion Phase
    * Evaluate all build scripts
    * Build object model (Gradle -> Project -> Task, etc)
    * Build task exeuction graph
    ** All tasks are configured before any are executed **
    ** If they contain print statements they will be executed ** 

* Execution Phase
    * Execute (subset of) tasks

NOTES:
    * --dry-run executes tasks without executing its actions
*/